Сделать процессор.

Мегасложные планы:
Пускай это будет целочисленный процессор, оперирующий 18-ти битными числами.
Двухпортовая память 36 длинной. Пускай команды будут 18 и 36 бит.
Многостадийный конвеер выборка данных, обработка, запись.
Регистров пускай будет совсем мало (например 4 шт).


Простые планы:
18-ти битный процессор.
18-ти битные регистры.
18-ти битные инструкции, возможна 36-x битная инструкция, с загрузкой imm данных потока команд.
Память команд и данных разделена.

Регистров общего назначения 8 штук. r0-r7
	r7 == sp - stack pointer
Спецрегистры
	ip - instruction pointer.
	
	
В большинстве инструкций есть два операнда. DST/SRC - это 6 бит.
Остается 12 бит.
imm короткий пускай будет -128 до +127
Т.е. для операций с двумя операндами и imm остается 4 бита

load rX, imm
	Есть короткий load на 18 бит команду, есть длинный на 36 бит.
	Короткий может загружать числа от -128 до +127 (может больше получится выделить, надо глянуть)
	Длинный весь диапазон 18 бит.

load rX, [rY+imm]
store [rY+imm], rX
move rX, rY

Синтаксис
r1 = r2[123]
r2[123] = r1
r4 = r5

Арифметика
op = add, or, xor, and, mul, imul
op rX, imm
op rX, rY

Синтаксис
r5 += 122
r2 |= r3
r4 &= 122


Для стека push/pop пока не будет, пускай это будет
sp[imm] = rX
а stack frame можно и сразу выделить, сколько потребуется при call

Условные операции: больше, меньше, равно нулю, больше или равно нулю, меньше или равно нулю.
	if(rX>0) goto Label
	Вместо goto Label может быть любая операция?


Безусловные переходы 
goto imm
goto rX
goto ip+imm

Явных call/return не будет.
	Для return достаточно goto [sp+imm]
	Для call достаточно sp[0] = ip


	
http://iverilog.wikia.com/wiki/Simulation


Порядок действий.
- написать свой интерпретатор на С++
- написать свой ассемблер на С++



-----------------------------------------------------
Пример записи на ассемблере низкоуровневый.
func:
	//3 переменных выделенны в стеке 
	sp -= 3
	//3 переменные в стеке очищенны нулями
	r6 = 0
	sp[0] = r6
	sp[1] = r6
	sp[2] = r6
	
	r1 = 123
	r2 = 0
Label:	
	r3 = r0[0]
	r2 += r3
	
	r0 += 1
	r1 -= 1
	if(r1>0) goto Label;
	
	r0 = r1
	sp += 4
	goto [sp-1] //вмеcто ret
	
	
Вызов функции:
	mov r0, 456
	mov [sp], ip
	

	
	
-----------------------------------------------------
Инициализировать память командами. --ok
Сделать "файл регистров", в котором есть два порта для чтения и один для записи. --ok
Процессор должен ip инкрементировать. --ok
Первая команда rx = imm11
Вторая команда rx = ry[imm8]

Вторая команда if(rx op) goto ip+addr
	переходим по относительному адресу условно и безусловно
Проверка на memory fault?


- Ассемблер
	- распарсить регистры, операции, комментарии --ok
	- rx = imm11 --ok
	- rx = ry + imm8
	
	
GTKWave
	
В рамках изучения Verilog и Cyclone IV решился таки наисать свой маленький процессор.
Хочется, чтобы он не слишком много места занимал в логических ячейках. Был более-менее быстрым. И чтобы более-менее удобный ассемблер был.
Задачи универсальности и совместимости не стоит.

Данные в блоках памяти Cyclone IV кратны девяти байтам. Умножители тоже 9x9 или 18x18. Так что процессор у меня будет 18-ти битным. Да, я знаю что это совсем нестандартное число, ну и ладно. 18 еще выбранно для того, чтобы регистры занимали мало триггеров.

Память будет раздельная. Один блок памяти для команд (512 слов максимум), и один блок памяти для данных. Блок памяти для команд можно будет шарить между двумя процессорами, чтобы два процессора выполняли одну программу, но над разными данными.

Мне кстати такая организация сильно напоминает shader processor в GPU.

Регистров общего назначения будет 8 штук r0-r7. Еще один дополнительный регистр ip. Регистр r7 пускай будет по совместительству stack pointer (sp). Регистров мало, потому как планирую их на триггерах делать, а их надо экономить.

Каждая команда будет занимать одно слово и выполняться за один такт процессора. Потом возможно добавлю ожидание данных из внешней памяти, но это потом.


Ассемблер тоже сделаю немного нестандартным. Пускай на каждой строчке будет одна команда, но будут они выглядеть немного похожими на C.
Пример:
    r0 = 12 //Загрузка числа циклов
    r1 = 0x230 //Загрузка адреса
    r2 = 0x350 
    r3 = 0
Loop:
    r4 = r1[0] //Загрузка по адресу r1
    r5 = r1[1] //Загрузка по адресу r1+1
    r4 += r5   //Сложение двух чисел
    r2[0] = r4 //Запись по адресу r2
    r1 += 2    //Сложение регистра с константой
    r2 += 1
    r0 -= 1
    if(r0>0) goto Loop //Условный переход

Пока это все чистый сон разума. Сначала разработаю на Icarus Verilog, а потом буду портировать на Cyclone IV.
Особое внимание уделю операции умножения. Чтобы она не только умножала, но и сдвигала на требуемое количество битов результат. Т.е. что-бы получилась fixed point арифметика более-менее быстрая.
Потом будет интересно посмотреть, на какой максимальнй частоте запустится этот монстр.

PS: Ну и для интересующихся. Начал потихоньку писать процессор и ассемблер. Пока работают только две команды
	rX = imm11
	rX = rY + imm8
Вобщем как говорится: Лиха беда, начало!


--------------------------
Подумаем над тем, чтобы SP вынести отдельно и добавить LR (link register)
Добавив LR регистр мы сможем сделать атомарной операцию call 
Вынеся отдельно SP регистр мы дополнительно освобождаем один регистр общено назначения.
Для SP регистра нам не нужно ALU операций (кроме +imm8), и это возможно есть плюс.

Подумать, нужно ли data_write_enable как-то ограничиать, чтобы не тот адрес не записался...

- избавится от define в alu
- переделать операции текущие так, чтобы не требовалось imm в alu_data0 --ok
- условные операции --ok
- условные переходы на ассембрере --ok
	Label:
	if(rx>=0) goto Label

- безусловный goto --ok
- проверить все условные операции  --ok
- условные операции четное/нечетное

- сделать укороченную форму для rx = rx + imm8
	rx += imm8
	
- арифметические операции --ok
	rx op= ry
	
- перепроверить условный переход --ok
- перепроверить запись в память --ok

Пускай sp==rx7

- функция call imm14 --ok
	sp[0] = ip+1
	ip = imm14
- функция return --ok
	ip = sp[0]

- проверить mulxx блок --ok

- умножение со сдвигом --ok
	пусть выглядит так
	знак числа задаем при помощи 
	rx = (rx * ry) >> imm6 signed(rx, ry)
	
	mul(rx's, ry's, imm6)
	's - означает signed
	imm6 - на сколько сдвигаем влево
	rx - in/out
	ry - in
	
	0x40000-x

- синтаксический сахара пока не будет, потом подумаем о С подобных функциях (тогда потребуется еще и дизассемблер)
	
- if(odd(rx)) if(even(rx))

- shortcut sp alias r7 --ok
- shortcut rx += imm8 --ok
- shortcut rx = ry --ok
	
- сделать несколько простых примеров --ok
	вычисляем факториал рекурсивно --ok
	заполняем память последовательно возрастающими значениями --ok
	
- дебаговый интерфейс для отладки процессора
	- возможность слить регистры с процессора
	- возможность остановить процессор

https://www.nandland.com/vhdl/modules/module-uart-serial-port-rs232.html

- определить debug interface
	останавливает процессор, во время остановки сливает данные
	
- ввести команду ожидания внешнего события (для того, чтобы сигнализировать об окончании программы) --ok
	wait
	ожитать выполнения программы
	заполнять программу не nop, а wait инструкциями

- проверить debug interface
	сливать при помощи его информацию о регистрах
	сравнить со слитой через fwrite
	
	-Dkey=value аналог `define key value
	-Dkey аналог `define key
	-P<symbol>=<value> аналог defparam U0.my_secret = 11;
	-s topmodule - выбор topmodule для запуска
	

- перенести test.py в py директорию --ok

- сделать проект под Cyclone IV EP4CE10E22C8N
	Файлы в пустом проекте
	.:
	db
	test_asm18.qpf
	test_asm18.qsf

	./db:
	test_asm18.db_info
	test_asm18.quiproj.3898.rdr.flock	

	- скопипастить код для светодиодиков и кнопок --ok
	- скопипастить код UART --ok

- сделать простейший тест на залить/слить память
- подключить процессор и исправить ошибки и предупреждения
- делать тесты, проверять, что они совпадают с iverilog

- общение по uart
	Пускай все общение будет порциями кратными трем байтам.
	Три байта потому как в них вмещается 18 бит.

	Если более 100 милисекунд не было продолжения команды,
	то значит надо ждать команду заново на устройстве.

	Команды хоста.
		Processor reset=1/0.
		Write to code memory.
		Write to data memory.
		Processor debug stop=1/0
		Read code memory.
		Read data memory.
		Read registers.

	Сигналы, которые посылает девайс без участия хоста.
		Программа остановилась.


	Как вариант данные приниматься на устройство могут в таком формате.
	1 байт - команда.
	2 байта - адрес
	2 байта - количество данных

	Данные для 18 бит регистров/памяти кратны трем байтам.

	0 - set led --ok
	1 - write to data memory. --ok
	2 - read data memory. --ok
	3 - write to code memory. --ok
	4 - read code memory. --ok

- стереть summator.v --ok

- проверить PROCESSOR_DEBUG_INTERFACE --ok


- прикрутить процессор  --ok
	- скомпилировать --ok
	- команда reset (on/off) --ok
	- команда Read registers --ok

- первый тест 
	mov.asm18
	почемуто ip на 1 больше, чем должен быть

- записать данные тества в файл
	сравнить с получаемым от iverilog

- приделать hardware multiplier

--------------------------------
Bevore implement processor

Flow Status	Successful - Sun Feb 11 18:13:08 2018
Quartus Prime Version	16.1.0 Build 196 10/24/2016 SJ Lite Edition
Revision Name	test_asm18
Top-level Entity Name	test_asm18
Family	Cyclone IV E
Device	EP4CE10E22C8
Timing Models	Final
Total logic elements	288 / 10,320 ( 3 % )
Total registers	157
Total pins	13 / 92 ( 14 % )
Total virtual pins	0
Total memory bits	18,432 / 423,936 ( 4 % )
Embedded Multiplier 9-bit elements	0 / 46 ( 0 % )
Total PLLs	0 / 2 ( 0 % )

-----------------------------------------------

- пускай reset может переводить и в состояние, когда  --ok
	debug_get_param = 1

- clear memory --ok

- все равно ip на 1 лишний такт перемещается
	упростить процессор, чтобы в нем было только 2 команды 
	rx = imm11
	wait

- замедлить сооовсем процессор, добавить 1 квант ничегонеделания после каждой команды --ok
	после этого процессор заработал на mov команде!

- проверить базово замедленный процессор
	0xA wait --ok
	0x1 rx = imm11 --ok
	0x0 rx = ry + imm8 --ok
	0x2 rx = imm11 << 7 --ok
	0x4 ry[imm8] = rx --ok
	0x3 rx = ry[imm8]