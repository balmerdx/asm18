Сделать процессор.

Мегасложные планы:
Пускай это будет целочисленный процессор, оперирующий 18-ти битными числами.
Двухпортовая память 36 длинной. Пускай команды будут 18 и 36 бит.
Многостадийный конвеер выборка данных, обработка, запись.
Регистров пускай будет совсем мало (например 4 шт).


Простые планы:
18-ти битный процессор.
18-ти битные регистры.
18-ти битные инструкции, возможна 36-x битная инструкция, с загрузкой imm данных потока команд.
Память команд и данных разделена.

Регистров общего назначения 8 штук. r0-r7
	r7 == sp - stack pointer
Спецрегистры
	ip - instruction pointer.
	
	
В большинстве инструкций есть два операнда. DST/SRC - это 6 бит.
Остается 12 бит.
imm короткий пускай будет -128 до +127
Т.е. для операций с двумя операндами и imm остается 4 бита

load rX, imm
	Есть короткий load на 18 бит команду, есть длинный на 36 бит.
	Короткий может загружать числа от -128 до +127 (может больше получится выделить, надо глянуть)
	Длинный весь диапазон 18 бит.

load rX, [rY+imm]
store [rY+imm], rX
move rX, rY

Синтаксис
r1 = r2[123]
r2[123] = r1
r4 = r5

Арифметика
op = add, or, xor, and, mul, imul
op rX, imm
op rX, rY

Синтаксис
r5 += 122
r2 |= r3
r4 &= 122


Для стека push/pop пока не будет, пускай это будет
sp[imm] = rX
а stack frame можно и сразу выделить, сколько потребуется при call

Условные операции: больше, меньше, равно нулю, больше или равно нулю, меньше или равно нулю.
	if(rX>0) goto Label
	Вместо goto Label может быть любая операция?


Безусловные переходы 
goto imm
goto rX
goto ip+imm

Явных call/return не будет.
	Для return достаточно goto [sp+imm]
	Для call достаточно sp[0] = ip


	
http://iverilog.wikia.com/wiki/Simulation


Порядок действий.
- написать свой интерпретатор на С++
- написать свой ассемблер на С++



-----------------------------------------------------
Пример записи на ассемблере низкоуровневый.
func:
	//3 переменных выделенны в стеке 
	sp -= 3
	//3 переменные в стеке очищенны нулями
	r6 = 0
	sp[0] = r6
	sp[1] = r6
	sp[2] = r6
	
	r1 = 123
	r2 = 0
Label:	
	r3 = r0[0]
	r2 += r3
	
	r0 += 1
	r1 -= 1
	if(r1>0) goto Label;
	
	r0 = r1
	sp += 4
	goto [sp-1] //вмеcто ret
	
	
Вызов функции:
	mov r0, 456
	mov [sp], ip
	

	
	
-----------------------------------------------------
Инициализировать память командами. --ok
Сделать "файл регистров", в котором есть два порта для чтения и один для записи. --ok
Процессор должен ip инкрементировать. --ok
Первая команда rx = imm11
Вторая команда rx = ry[imm8]

Вторая команда if(rx op) goto ip+addr
	переходим по относительному адресу условно и безусловно
Проверка на memory fault?


- Ассемблер
	- распарсить регистры, операции, комментарии --ok
	- rx = imm11 --ok
	- rx = ry + imm8
	
	
GTKWave
	
В рамках изучения Verilog и Cyclone IV решился таки наисать свой маленький процессор.
Хочется, чтобы он не слишком много места занимал в логических ячейках. Был более-менее быстрым. И чтобы более-менее удобный ассемблер был.
Задачи универсальности и совместимости не стоит.

Данные в блоках памяти Cyclone IV кратны девяти байтам. Умножители тоже 9x9 или 18x18. Так что процессор у меня будет 18-ти битным. Да, я знаю что это совсем нестандартное число, ну и ладно. 18 еще выбранно для того, чтобы регистры занимали мало триггеров.

Память будет раздельная. Один блок памяти для команд (512 слов максимум), и один блок памяти для данных. Блок памяти для команд можно будет шарить между двумя процессорами, чтобы два процессора выполняли одну программу, но над разными данными.

Мне кстати такая организация сильно напоминает shader processor в GPU.

Регистров общего назначения будет 8 штук r0-r7. Еще один дополнительный регистр ip. Регистр r7 пускай будет по совместительству stack pointer (sp). Регистров мало, потому как планирую их на триггерах делать, а их надо экономить.

Каждая команда будет занимать одно слово и выполняться за один такт процессора. Потом возможно добавлю ожидание данных из внешней памяти, но это потом.


Ассемблер тоже сделаю немного нестандартным. Пускай на каждой строчке будет одна команда, но будут они выглядеть немного похожими на C.
Пример:
    r0 = 12 //Загрузка числа циклов
    r1 = 0x230 //Загрузка адреса
    r2 = 0x350 
    r3 = 0
Loop:
    r4 = r1[0] //Загрузка по адресу r1
    r5 = r1[1] //Загрузка по адресу r1+1
    r4 += r5   //Сложение двух чисел
    r2[0] = r4 //Запись по адресу r2
    r1 += 2    //Сложение регистра с константой
    r2 += 1
    r0 -= 1
    if(r0>0) goto Loop //Условный переход

Пока это все чистый сон разума. Сначала разработаю на Icarus Verilog, а потом буду портировать на Cyclone IV.
Особое внимание уделю операции умножения. Чтобы она не только умножала, но и сдвигала на требуемое количество битов результат. Т.е. что-бы получилась fixed point арифметика более-менее быстрая.
Потом будет интересно посмотреть, на какой максимальнй частоте запустится этот монстр.

PS: Ну и для интересующихся. Начал потихоньку писать процессор и ассемблер. Пока работают только две команды
	rX = imm11
	rX = rY + imm8
Вобщем как говорится: Лиха беда, начало!


--------------------------
Подумаем над тем, чтобы SP вынести отдельно и добавить LR (link register)
Добавив LR регистр мы сможем сделать атомарной операцию call 
Вынеся отдельно SP регистр мы дополнительно освобождаем один регистр общено назначения.
Для SP регистра нам не нужно ALU операций (кроме +imm8), и это возможно есть плюс.

Подумать, нужно ли data_write_enable как-то ограничиать, чтобы не тот адрес не записался...

- избавится от define в alu
- переделать операции текущие так, чтобы не требовалось imm в alu_data0 --ok
- условные операции --ok
- условные переходы на ассембрере --ok
	Label:
	if(rx>=0) goto Label

- безусловный goto --ok
- проверить все условные операции  --ok
- условные операции четное/нечетное

- сделать укороченную форму для rx = rx + imm8
	rx += imm8
	
- арифметические операции --ok
	rx op= ry
	
- перепроверить условный переход --ok
- перепроверить запись в память --ok

Пускай sp==rx7

- функция call imm14 --ok
	sp[0] = ip+1
	ip = imm14
- функция return --ok
	ip = sp[0]

- умножение со сдвигом
	пусть выглядит так
	знак числа задаем при помощи 
	rx = (rx * ry) >> imm6 signed(rx, ry)
	
	mul(rx's, ry's, imm6)
	's - означает signed
	imm6 - на сколько сдвигаем влево
	rx - in/out
	ry - in

- синтаксический сахара пока не будет, потом подумаем о С подобных функциях (тогда потребуется еще и дизассемблер)
	