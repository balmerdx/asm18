
18 бит длинна минимальной инструкции.
4 верхних бита - выбор семейства команд

8 регистров регисторов общего назначения r0-r7
дополнительные регистры ip, sp, lr
ip - instruction pointer указывает на исполненяемую команду
sp - stack pointer указывает на стек (это будет r7 регистр)

rx,ry - регистры общего назначения 3 бита для выбора (r0-r7)
sx,sy - регистры специальные 2 бита для выбора (ip, sp, lr)
rsx - регистры общего назначения и специальные 4 бита для выбора (r0-r7, ip, sp, lr)

imm6 число в диапазоне -32..+31
imm8 число в диапазоне -128..+127
imm11 - 11 бит в интервале -1024..1023


8 регистров 2 операнда, imm8 бит
Остается 4 бита на операции с двумя аргументами и imm8

0x0 rx ry imm8 --ok
	Сложение с числом (при сложении с 0 это является операцией move)
	rx = ry + imm8
	
	r0 = r0 + 0 - это получается операция NOP
	
0x1 rx imm11 --ok
	Загрузка непосредственного аргумента
	rx = imm11
	
0x2 rx imm11 --ok
	Загрузка верхней части числа
	rx = imm11 << 7
	Вместе с операцией rx = rx + imm8 можно загрузить полное число
	
0x3 rx ry imm8 --ok
	Загрузка из памяти по суммарному адресу
	rx = ry[imm8]

0x4 rx ry imm8 --ok
	Запись в память
	ry[imm8] = rx

0x5 rx op imm8 --ok
	Условный переход по относительному адресу
	op 3 бита - операция сравнения над регистром rx
	может быть 
		op=0 rx==0
		op=1 rx<0
		op=2 rx>0
		op=3 rx<=0
		op=4 rx>=0
		op=5 rx[0]==0 //нулевой бит содержит 0
		op=6 rx[0]!=0 //нулевой бит содержит 1
		op=7 безусловный переход
	if(rx op) goto ip+addr
	

0x6 rx ry zero5 op3 --ok
	Арифметические операции над двумя регистрами
	rx - является одновременно операндом и результатом операции
	ry - операнд
	op3 - 3 бита
	op=2 rx += ry //rx = rx + ry
	op=3 rx -= ry //rx = rx - ry
	op=4 rx &= ry //rx = rx & ry
	op=5 rx |= ry //rx = rx | ry
	op=6 rx ^= ry //rx = rx ^ ry
	op=7 rx = ~ry
	

0x7 rx ry sign(rx) sign(ry) imm6
	Умножение (как знаковое, так и беззнаковое)
	!!!! Пока пускай будет только знаковое умножение.
	rx = (rx*ry) >> imm6 //Беззнаковое
	rx = (rx's*ry's) >> imm6 //Знаковое
	Варианты тоже возможны
	rx = (rx*ry's) >> imm6
	rx = (rx's*ry) >> imm6 

0x8 imm14
	sp[0] = ip+1; ip = imm14 //call по абсолютному адресу
	
0x9 op3 ry imm8
	op=0 ip = ry[imm8] //return imm8==0 ry==sp
	
0xA zero14 
	wait - выставляем флаг ожидания. Ожидаем внешнего события.
	
