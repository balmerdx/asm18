
18 бит длинна минимальной инструкции.
4 верхних бита - выбор семейства команд

8 регистров регисторов общего назначения r0-r7
дополнительные регистры ip, sp, lr
ip - instruction pointer указывает на исполненяемую команду
sp - stack pointer указывает на стек
lr - link register указывает, куда возвращаться после call

rx,ry - регистры общего назначения 3 бита для выбора
sx,sy - регистры специальные 2 бита для выбора
rsx - регистры общего назначения и специальные 4 бита для выбора
rx2 - r0-r3 2 бита

imm6 число в диапазоне -32..+31
imm8 число в диапазоне -128..+127
imm11 - 11 бит в интервале -1024..1023


8 регистров 2 операнда, imm8 бит
Остается 4 бита на операции с двумя аргументами и imm8

0x0 rx ry imm8
	Сложение с числом (при сложении с 0 это является операцией move)
	rx = ry + imm8
	
	r0 = r0 + 0 - это получается операция NOP
	
0x1 rx imm11
	Загрузка непосредственного аргумента
	rx = imm11
	
0x2 rx imm11
	Загрузка верхней части числа
	rx = imm11 << 7
	Вместе с операцией rx = rx + imm8 можно загрузить полное число
	
0x3 rx ry imm8
	Загрузка из памяти по суммарному адресу
	rx = ry[imm8]

0x4 rx ry imm8
	Запись в память
	ry[imm8] = rx

0x5 rx op imm8
	Условный переход по относительному адресу
	op 3 бита - операция сравнения над регистром rx
	может быть 
		op=0 rx==0
		op=1 rx<0
		op=2 rx>0
		op=3 rx<=0
		op=4 rx>=0
		op=5 rx[0]==0 //нулевой бит содержит 0
		op=6 rx[0]!=0 //нулевой бит содержит 1
		op=7 безусловный переход
	if(rx op) goto ip+addr
	

0x6 rx ry op8 
	Арифметические операции над двумя регистрами
	rx - является одновременно операндом и результатом операции
	ry - операнд
	op8 - 8 бит 
	op=0 rx += ry //rx = rx + ry
	op=1 rx -= ry //rx = rx - ry
	op=2 rx &= ry //rx = rx & ry
	op=3 rx |= ry //rx = rx | ry
	op=4 rx ^= ry //rx = rx ^ ry
	op=5 rx = ~ry
	

0x7 rx ry sign(rx) sign(ry) imm6
	Умножение (как знаковое, так и беззнаковое)
	rx = (rx*ry) >> imm6 //Беззнаковое
	rx = (rx's*ry's) >> imm6 //Знаковое
	Варианты тоже возможны
	rx = (rx*ry's) >> imm6
	rx = (rx's*ry) >> imm6 

0x8 imm14
	lr = ip+1; ip = imm14 //call по абсолютному адресу
	
0x9 rx op sx imm8
	op 1 bit
	op = 0 rx = sx[imm8]
	op = 1 sx[imm8] = rx
	
0xA	rsx op imm8
	op 2 bit
	Причем кодируется так 0xA rx tbx op imm8
	op = 0 rsx = sp[imm8]
	op = 1 sp[imm8] = rsx
	op = 2 rsx = sp+imm8 //Восновном ради sp = sp + imm8
	op = 3 sp = rsx+imm8
	
0xB	rsx rsy 0
	Причем кодируется так 0xB rx ry tbx tby 6'b0
	tbx - top bit rsx
	rsx = rsy
	
	
//0x9 rx op5 imm6 --не будем реализовывать, обойдемся умножением со сдвигом
//	Операции с одним операндом
//	op5 бит операция
//	imm6 - 6 бит число в интервале 0..63
	
//	op5=2  rx= rx << imm6 //беззнаковый сдвиг влево
//	op5=3  rx= rx >> imm6 //беззнаковый сдвиг вправо
//	op5=5  rx= rx sal imm6 //циклический сдвиг влево
//	op5=4  rx= rx sar imm6 //циклический сдвиг вправо
//	op5=5  #s rx= rx << imm6 //знаковый сдвиг влево
//	op5=6  #s rx= rx >> imm6 //знаковый сдвиг вправо

	
-------------------------------------------
Порядок операций.
	Выбирает данные по ip, не интерпретируя их.
	Выбирает данные из кода, агружает их в регистр. 0x1 rx imm13
	Сложение с числом. 0x4 rx ry imm8
